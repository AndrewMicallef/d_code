# segmentation and ROI extraction code
import numpy as np
import os
import h5py
import subprocess
import pymorph

import scipy.stats as stats
import scipy.signal as sig
import scipy.ndimage as nd

__all__ = ['pickCells', 'extractTimeCoursesFromSeries', 'extractTimeCoursesFromStack', 'avgFromROIInSeries', 'avgFromROIInStack', 'allPixelsFromROIInSeries', 'refineMask']

def pickCells(stack, seedPoints=None):
    """
    This is a wrapper function for MATLAB code that allows for semi-automated picking
    of cells via some MATLAB code from the Reid lab.  Depends on a simple matlab
    function which opens the hdf5 file and aligns the array, and writes it back out to
    another part of the hdf5 file

    Algorithm uses the average across time (axis=2) to form the image to pick cells with,
    generally is the average of the green channel

    Optional parameter seedPoints is a N x 2 np.array with coordinates of points to 'pre-click'
    Generated by core.morphProcessing.buildSeedPoints, for example.  Ideally sorted by brightest
    to dimmest object.

    Returns two 2d arrays- one is a binary array and one a labeled array

    :param stack: 3d nparray to use for picking.  
    :param seedPoints: optional, N x 2 numpy array
    :returns: (bwOut, mask): tuple of binary mask and labeled mask, both 2d numpy arrays
    """

    fovimage = np.mean(np.atleast_3d(stack),axis=2)

    if os.path.isfile('temp.hdf5'):
        os.system('rm -rf *.hdf5')
    f = h5py.File('temp.hdf5')
    f.create_dataset('fovimage',data=fovimage)
    if seedPoints is not None:
        f.create_dataset('seedPoints',data=seedPoints)
    else:
        f.create_dataset('seedPoints',data=np.array([]))
    f.close()

    # call picking code (external matlab function, which is itself a wrapper for java... yuck)
    print 'Launching MATLAB to pick cells...\n'
    handle = subprocess.Popen('matlab -nodesktop -r \'imCellEditinteractiveExternal\'',stdin=open('/dev/null'), shell=True, executable="/bin/bash")
    handle.wait()

    # import the masks and delete temporary files
    f = h5py.File('temp.hdf5','r')
    bwOut = np.array(f.get('bwOut')[:])
    #    mask = np.array(f.get('mask')[:])
    f.close()

    os.system("rm -rf *.hdf5")

    return bwOut, pymorph.label(bwOut)

def extractTimeCoursesFromSeries(imageSeries, mask):
    """Get timecourses of stack regions defined by a index 2-D array

    Really just a wrapper around extractTimeCoursesFromStack
    adds a dimension, extracts, and squeezes.

    Returns a N by time numpy array where N is the number of objects
    in labelImage.

    :param series: X by Y by time
    :param mask: 2-D labeled image of cell masks
    :returns: numobjects by time numpy array
    """
    return np.squeeze(extractTimeCoursesFromStack(np.expand_dims(imageSeries, axis=3), mask))
    
def extractTimeCoursesFromStack(imageStack, mask):
    """Get timecourses of stack regions defined by a index 2-D array

    Returns a N by time by trial numpy array where N is the number of objects
    in labelImage.

    :param stack: X by Y by time by trial
    :param labelImage: 2-D labeled image of cell masks
    :returns: traces: a numobjects by time by trial numpy array
    """

    Xsize, Ysize, nTimePoints, nTrials = imageStack.shape

    objectLabels = [i for i in set(mask.ravel())]
    #    objectLabels = [i for i in set(mask.ravel()) if i>0]
    nObjects = len(objectLabels)
    traces = np.zeros((nObjects,nTimePoints,nTrials))

    for i, obj in enumerate(objectLabels):
        index = mask == obj
        traces[i,:,:] = avgFromROIInStack(imageStack, index)

        # nPixels=np.sum(index)
        # objectTimeCourse = np.sum(stack[index,:,:],axis=0)/nPixels # all the time points, all the trials, for every X and Y which == object
        # traces[i,:,:]=objectTimeCourse

    return traces

def avgFromROIInSeries(imageSeries, binaryMask):
    """Computes an avgerage time series across all pixels in the mask.  

    :param imageSeries: X by Y by time
    :param binaryMask: binary mask image
    :returns: objectTimeCourse: numpy array, 1D, timeseries
    """
    nPixels = np.sum(binaryMask)
    objectTimeCourse = np.sum(imageSeries[binaryMask,:],axis=0)/nPixels # all the time points, all the trials, for every X and Y which == object
    return objectTimeCourse

def avgFromROIInStack(imageStack, binaryMask):
    """Computes an avgerage timeseries across all pixels in the mask, for all trials in the stack.  

    :param imageStack: X by Y by time by trial
    :param binaryMask: binary mask image
    :returns: objectTimeCourse: numpy array, 2D, timeseries by object
    """
    nPixels=np.sum(binaryMask)
    objectTimeCourse = np.sum(imageStack[binaryMask,:,:],axis=0)/nPixels # all the time points, all the trials, for every X and Y which == object
    return objectTimeCourse

def allPixelsFromROIInSeries(imageSeries, binaryMask):
    """Computes an pixel by pixel timeseries for all pixels in the mask, for all trials in the image series.
    Similar to avgFromROIInSeries, but doesn't average.
    
    :param imageSeries: X by Y by time
    :param binaryMask: binary mask image
    :returns: pixelValues: numpy array, 2D, pixel number by time
    """
    pixelValues = np.zeros((binaryMask.sum(), imageSeries.shape[2]))
    for i in range(imageSeries.shape[2]):
        iii = imageSeries[:,:,i]
        pixelValues[:,i] = iii[binaryMask.astype('bool')]
    return pixelValues

def refineMask(mask, imageSeries, numDilations=3, thresh=0.5, se=None):
    def corrMaskWithSourcePreConv(imageSeriesSmoothed, dilatedBinaryMask, sourceSmoothed):

        corrImage = np.zeros((imageSeries.shape[0], imageSeries.shape[1]))

        bounds = np.squeeze(pymorph.blob(dilatedMask, 'boundingbox', output='data'))
        for x in range(bounds[1], bounds[3]):
            for y in range(bounds[0], bounds[2]):
                if dilatedBinaryMask[x,y]>0:
                    corr = stats.pearsonr(sourceSmoothed[1:-1], imageSeriesSmoothed[x,y,:])[0]
                    corrImage[x,y] = corr
        return corrImage

    # calculate box for smoothing
    box = sig.boxcar(3)
    box = box / box.sum()

    imageSeriesSmoothed = nd.convolve1d(imageSeries, box, axis=2, mode='mirror')

    completeRefinedMask = np.zeros_like(mask)

    if se is None:
        se = np.array([[0,1,0],[1,1,1],[0,1,0]])
        #se = np.array([[1,1,1],[1,1,1],[1,1,1]])
    seedMask = mask.copy() > 0
    for rep in range(numDilations):
        seedMask = pymorph.dilate(seedMask, se)
    
    for maskIndex in range(1,mask.max()+1):
        origMask = mask == maskIndex

        dilatedOrigMask = origMask.copy() > 0
        for rep in range(numDilations):
            dilatedOrigMask = pymorph.dilate(dilatedOrigMask, se)

        forbiddenMask = np.logical_or(np.logical_and(seedMask, np.logical_not(dilatedOrigMask)), pymorph.dilate(completeRefinedMask))

        # make smoothed source
        source = avgFromROIInSeries(imageSeries, origMask)
        sourceSmoothed = np.convolve(source, box)

        dilatedMask = (mask==maskIndex).copy()
        for rep in range(numDilations+1):
            dilatedMask = pymorph.dilate(dilatedMask)

        corrMask = corrMaskWithSourcePreConv(imageSeriesSmoothed, dilatedOrigMask, sourceSmoothed)
        threshMask = corrMask >= thresh

        newMask = np.logical_and(np.logical_not(forbiddenMask), np.logical_or(threshMask, origMask))
        
        #completeRefinedMask = np.logical_xor(completeRefinedMask, newMask)
        completeRefinedMask += (newMask>0)*maskIndex
        #pdb.set_trace()
        completeRefinedMask[completeRefinedMask > maskIndex] = 0
        
    return completeRefinedMask
